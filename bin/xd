#!/bin/bash

set -e;

IFS=$' \t\n'; # do no dummy stuff

COMMAND=$(basename $0); # smart stuff is ok

BAD_SUBST_PARAMS="wrong number of parameters; expected pattern and replacement parameter-pairs following options"

function subset.script() {

  local head=${head:-''} tail=${tail:-''} split=${split:-$'\1'} quote=${quote:-"'"} flags=-E;

  # the following parameters are paired in twos:
  # $1 find-pattern, $2 replacement[, ...]
  # this format allows you to perform successive substitutions in a reliable way.

  (( $# % 2 || $# == 0 )) && {
    echo
    echo $COMMAND: ${FUNCNAME[1]}: error: $BAD_SUBST_PARAMS: an invalid number of substitution specifications were provided.
    echo
    echo $'\t'try: $COMMAND ${FUNCNAME[1]} CUT-PATTERN PASTE-TEXT[, CUT-PATTERN PASTE-TEXT[, ...]]
    echo
    exit 1;
  } >&2;

  echo -n sed $flags;
  while (( $# )); do printf " -e ${quote}s%sg${quote}" "${split}${head}${1}${tail}${split}${2}${split}"; shift 2; done;
  echo ';'

}

function filter.script() {

    local head=${head:-''} tail=${tail:-''} quote=${quote:-"'"} flags=-E;

    [[ "$1" == -e ]] && { # for invert match == '-e[xclude]'
      flags+=" -v"; shift;
    }

    [[ "$1" == -- ]] || {
      echo
      echo "$COMMAND: ${FUNCNAME[1]}: error: match specifications must be preceded by \`--' for disambiguation of matches and match options"
      echo
      exit 1;
    } >&2;
    
    shift;
    
    echo -n grep $flags;
    while (( $# )); do printf " -e ${quote}${head}%s${tail}${quote}" "$1"; shift; done; 
    echo ';';
    
}

function subset() {

  local content=

  (( $# == 0 )) && {
    echo
    echo "$COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS; 0 parameters were provided"
    echo
    echo $'\t'try: $COMMAND $FUNCNAME CUT-PATTERN PASTE-TEXT[ CUT-PATTERN PASTE-TEXT[ ...]]
    echo
    exit 1;
  } >&2;

  source <(subset.script "$@");

}

BAD_FILTER_PARAMS="wrong number of parameters; expected pattern-match(es) following options"

function filter() {

  (( $# == 0 )) && {
    echo
    echo "$COMMAND: $FUNCNAME: error: $BAD_FILTER_PARAMS; 0 parameters were provided"
    echo
    echo $'\t'try: $COMMAND $FUNCNAME [OPTIONS] -- MATCH-PATTERN ...
    echo
    exit 1;
  } >&2;

  source <(filter.script "$@");

}

function write-parameter-pipe () {
  printf "%s\n" "$@";
}

function read-parameter-pipe () {
  local lines;
  readarray lines;
  "$@" "${lines[@]%$'\n'}";
}

function catalog() {

  [[ $1 == -d ]] && {
    local -i max=$2; shift 2;
  }

  [[ "$1" == -- ]] || {
    echo
    echo "$COMMAND: ${FUNCNAME}: error: directory names must be preceeded by \`--' for disambiguation of options and files"
    echo
    echo $'\t'try: $COMMAND ${FUNCNAME} [-d NUMBER] -- DIRECTORY ...
    echo
    exit 1;
  } >&2;

  shift;

  local dir= file=

  if [[ "$d" == '' ]]; then local -i d=0; fi;
  d=$d+1;
  (( max > 0 && d > max )) && return;      
  for dir; do
    for file in "${dir%/}"/*; do
      [ -e "$file" ] || [ -L "$file" ] || continue
      if [ -d "$file" ]; then
        printf "%s\n" "$file"
        catalog -- "$file"
      else
        printf "%s\n" "$file"
      fi
    done
  done;
  
}

function realpaths() {
  for arg; do realpath "$arg" || continue; done;
  true;
}

function parents() {
  for arg; do
    [[ $arg == / ]] && continue;
    dirname "$arg" || continue;
  done;
  true;
}

function names() {
  for arg; do
    [[ $arg == / ]] && continue;
    basename "$arg" || continue; 
  done;
  true;
}

function files() {
  for file; do [[ -d "$file" ]] && continue; [[ -e "$file" ]] && echo "$file"; done;
  true;
}

function links() {

  local -i include=1;
  
  [[ "$1" == -e ]] && { include=0; shift; }
  
  [[ "$1" == -- ]] || {
    echo
    echo "$COMMAND: ${FUNCNAME}: error: file specifications must be preceded by \`--' for disambiguation of files and options"
    echo
    echo $'\t'try: $COMMAND ${FUNCNAME[1]} [-e] -- FILE ...
    echo
    exit 1;
  } >&2;
  
  shift;
  
  (( include )) && {
    for file; do
      if [[ -h "$file" ]]; then 
        echo "$file";
      fi;
    done;
    return 0;
  }
  
  for file; do
    if [[ -h "$file" ]]; then continue; fi;
    echo "$file";
  done;
  
  return 0;
  
}

function directories() {
  for file; do 
    if [[ -d $file ]]; then echo "$file"; fi;
  done;
  true;
}

function key-within-list() { # make sure you test this result in error-mode-shells
  local key="$1"; shift;
  [[ "$1" == -- ]] || {
    echo
    echo "$COMMAND: ${FUNCNAME[1]}: error: match specifications must be preceded by \`--' for disambiguation of matches and match options"
    echo
    exit 1;
  } >&2;
  shift;
  opkit.match "$key" "$@"; 
}

function -e:() { # runs exclusive filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | filter -e -- $1;
}

function -i:() { # runs inclusive regular expression filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | filter -- $1;
}

function -f() { # filters content by existing files
  call "$@" | read-parameter-pipe  files;
}

function -d() { # filters content by existing directories
  call "$@" | read-parameter-pipe  directories;
}

function -z() { # reset IFS
  IFS=$' \t\n' call "$@";
}

function -z:() { # sets IFS: PARAMETER
  IFS=$1 call "${@:2}";
}

function -r() {
  call "$@" | read-parameter-pipe  realpaths;
}

function -l() {
  call "$@" | read-parameter-pipe  links --;
}

function -L() {
  call "$@" | read-parameter-pipe  links -e --;
}

function -p() {
  call "$@" | read-parameter-pipe  parents;
}

function -s:() {
  [[ $1 == u ]] && {
    shift;
    call "$@" | uniq;
    return;
  }
  [[ $1 == v ]] && {
    shift;
    call "$@" | sort -V;
    return;
  }
  [[ $1 == n ]] && {
    shift;
    call "$@" | sort;
    return;
  }
  echo "$COMMAND: error: no sorting solution found for: $1";
  exit 1;
}

function -q:() {
  quote=$1 call "${@:2}";
}

function -Q:() { # this option only affects subset
  split=$1 call "${@:2}";
}

function -t() {
  tail=\$ call "${@}";
}

function -t:() {
  tail=$1 call "${@:2}";
}

function -h:() {
  head=$1 call "${@:2}";
}

function dump.function.table() {
  local all="$(env -i DEBUG=1 $0 declare -pF | filter -e -- '\.' | cut -d ' ' -f3)"
  echo OPTIONS=\"$(write-parameter-pipe  "$all" | filter -- '^-')\";
  echo FUNCTIONS=\"$(write-parameter-pipe  "$all" | filter -e -- '^-' '^call$')\";
}

function --get-theatre() {
  dump.function.table;
}

function -h() {
  (( $# == 0 )) && {
    --help
  }
  head=\^ call "${@}";
}

function trace() {
  DEBUG=1 call "$@";
}

function opkit.match() {
  local match="$1"; shift;
  for param; do [[ "$match" == "$param" ]] && return 0; done;
  return 1;
}

function opkit.keys() { eval echo \${!$1[@]}\;; }

function opkit.set() {
  local destination=$1 source; shift;
  for source; do
    local key="${source/=*/}";
    local value="${source/*=/}"
    printf -v ${destination}$key %s "$value"
  done;
}

function opkit.get() {
  local source=$1 name; shift;
  for name; do eval echo \"\${$source[$name]}\"\;; done;
}

function opkit.content() { eval echo \${$1[@]}; }

function opkit.begin() { opkit.set $1 [POINT]=1 [SUBPOINT]=0; }

function opkit.dump() { 

  local name;
  for name in $(opkit.keys $1); do
    printf '%s: %s\n' $name "$(opkit.get $1 $name)";
  done

}

function opkit.parse() {

  # PARAMETERS: $1 and $2 are names of associative arrays.
  # the output of the function will be placed in $2
  # the state of the parsing is saved in $1.

  # the remaining parameters are parsed. the number of items parsed are
  # returned in 2[SIZE].

  local OK_STATE=$1 RCRD_PARAMETER=$2; shift 2;

  local POINT=$OK_STATE[POINT] SUBPOINT=$OK_STATE[SUBPOINT];
  local PARAMETER=BASH_REMATCH[1] VALUE=BASH_REMATCH[2]
    
  opkit.set $RCRD_PARAMETER [BRANCH]=0 [POINT]=${!POINT} \
    [INPUT]="$1" [SUBPOINT]=0 [VALUE]='' [SHORT]=0 [SIZE]=1;

  # 1 test for long option
  [[ "$1" =~ ^--([a-zA-Z-]*[a-zA-Z])$ ]] && {
    opkit.set $RCRD_PARAMETER [BRANCH]=1 [PARAMETER]="${!PARAMETER}";
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE LONG) || return 11;
    let $POINT++;
    return 0;
  }

  # 2 test for long option with setting specification
  [[ "$1" =~ ^--([a-zA-Z-]*[a-zA-Z]):$ ]] && {
    opkit.set $RCRD_PARAMETER [BRANCH]=2 [PARAMETER]="${!PARAMETER}" \
      [VALUE]="$2" [SIZE]=2;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE LONG) || return 21;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SETTINGS) || \
      return 22;
    let $POINT+=2;
    return 0;
  }

  # 3 test for long option with setting specification and data
  [[ "$1" =~ ^--([a-zA-Z-]*[a-zA-Z])[:=](.*)$ ]] && {
    opkit.set $RCRD_PARAMETER [BRANCH]=3 [PARAMETER]="${!PARAMETER}" \
      [VALUE]="${!VALUE}";
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE LONG) || return 31;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SETTINGS) || \
      return 32;
    let $POINT++;
    return 0;
  }

  # 4 test for short option
  [[ "$1" =~ ^-([a-zA-Z])$ ]] && {
    opkit.set $RCRD_PARAMETER [BRANCH]=4 [PARAMETER]="${!PARAMETER}" \
      [SHORT]=1;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SHORT) || return 41;
    let $POINT++;
    return 0;
  }

  # 5 test for short option with setting
  [[ "$1" =~ ^-([a-zA-Z]):$ ]] && {
    opkit.set $RCRD_PARAMETER [BRANCH]=5 [PARAMETER]="${!PARAMETER}" \
      [VALUE]="$2" [SHORT]=1 [SIZE]=2;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SHORT) || return 51;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SETTINGS) || \
      return 52;
    let $POINT+=2;
    return 0;
  }

  # 6 test for short option with setting and data
  [[ "$1" =~ ^-([a-zA-Z])[:=](.+)$ ]] && {
    opkit.set $RCRD_PARAMETER [BRANCH]=6 [PARAMETER]="${!PARAMETER}" \
      [VALUE]="${!VALUE}" [SHORT]=1;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SHORT) || return 61;
    opkit.match "${!PARAMETER}" $(opkit.get $OK_STATE SETTINGS) || \
      return 62;
    let $POINT++;
    return 0;
  }
  
  # 7 test for multiple short option
  [[ "$1" =~ ^-([a-zA-Z]+)$ ]] && {
    local match=${BASH_REMATCH[1]};
    local -i length=${#match};
    local C=${match:${!SUBPOINT}:1};
    opkit.set $RCRD_PARAMETER [BRANCH]=7 [PARAMETER]="$C" [POINT]=${!POINT} \
      [SUBPOINT]=${!SUBPOINT} [SHORT]=1;
    opkit.match "${C}" $(opkit.get $OK_STATE SHORT) || return 71;
    let $SUBPOINT++;
    if (( $SUBPOINT == length )); then
      opkit.set $RCRD_PARAMETER [SIZE]=1;
      let $POINT++ $SUBPOINT=0;
    else
      opkit.set $RCRD_PARAMETER [SIZE]=0;
      opkit.match "${C}" $(opkit.get $OK_STATE SETTINGS) && {
        opkit.match "$C" $(opkit.get $OK_STATE HAS_DEFAULT) || return 72;
      } 
    fi;
    return 0;
  }

  # 8 test for multiple short option with setting
  [[ "$1" =~ ^-([a-zA-Z]+):$ ]] && {
    local match=${BASH_REMATCH[1]};
    local -i length=${#match};
    local C=${match:${!SUBPOINT}:1};
    opkit.set $RCRD_PARAMETER [BRANCH]=8 [PARAMETER]="$C" [POINT]=${!POINT} \
      [SUBPOINT]=${!SUBPOINT} [SHORT]=1;
    opkit.match "${C}" $(opkit.get $OK_STATE SHORT) || return 81;
    let $SUBPOINT++;
    if (( $SUBPOINT == length )); then
      opkit.set $RCRD_PARAMETER [VALUE]="$2";
      opkit.set $RCRD_PARAMETER [SIZE]=2;
      opkit.match "${C}" $(opkit.get $OK_STATE SETTINGS) && {
        opkit.set $RCRD_PARAMETER [VALUE]="$2" [SIZE]=2;
        let $POINT++;
      } 
      let $POINT++ $SUBPOINT=0;
    else
      opkit.set $RCRD_PARAMETER [SIZE]=0;
      opkit.match "${C}" $(opkit.get $OK_STATE SETTINGS) && {
        opkit.match "$C" $(opkit.get $OK_STATE HAS_DEFAULT) || return 82;
      } 
    fi;
    return 0;
  }

  # 9 test for multiple short option with setting and data
  [[ "$1" =~ ^-([a-zA-Z]+)[:=](.+)$ ]] && {
    local match=${BASH_REMATCH[1]};
    local -i length=${#match};
    local C=${match:${!SUBPOINT}:1};
    opkit.set $RCRD_PARAMETER [BRANCH]=9 [PARAMETER]="$C" [POINT]=${!POINT} \
      [SUBPOINT]=${!SUBPOINT} [SHORT]=1;
    opkit.match "${C}" $(opkit.get $OK_STATE SHORT) || return 91;
    let $SUBPOINT++;
    if (( $SUBPOINT == length )); then
      opkit.set $RCRD_PARAMETER [VALUE]="${BASH_REMATCH[2]}";
      opkit.set $RCRD_PARAMETER [SIZE]=1;
      opkit.match "${C}" $(opkit.get $OK_STATE SETTINGS) && {
        opkit.set $RCRD_PARAMETER [VALUE]="${!VALUE}";
      } 
      let $POINT++ $SUBPOINT=0;
    else
      opkit.set $RCRD_PARAMETER [SIZE]=0;
      opkit.match "${C}" $(opkit.get $OK_STATE SETTINGS) && {
        opkit.match "$C" $(opkit.get $OK_STATE HAS_DEFAULT) || return 92;
      } 
    fi;
    return 0;
  }
  return 1;
}

OPTIONS="--get-theatre --help -L -Q: -d -e: -f -h -h: -i: -l -p -q: -r -s: -t -t: -z -z:";
FUNCTIONS="catalog directories files filter key-within-list links names parents read-parameter-pipe  realpaths subset trace write-parameter-pipe";

(( DEBUG == 1 )) && {
  DEBUG_FUNCTIONS="declare dump.function.table filter.script subset.script";
}

declare -A CONFIG

opkit.set CONFIG [LONG]="get-theatre help"
opkit.set CONFIG [SHORT]="t L Q r d e f h i l l p q s z";
opkit.set CONFIG [SETTINGS]="h Q t e i l q z s"
opkit.set CONFIG [HAS_DEFAULT]="h t z"

opkit.begin CONFIG;

function dump.trace() {
{
      echo
      echo $command trace: 
      echo
      echo $'  0 '[:OUT-\>]
      echo  '  + '[compile]
      echo $'  1 'read OPTIONS left to right, for logical [dependency] order
      echo $'  + '[direction-flip: enter/exit/return]
      echo $' -1 'read right to left for output [composition] order.
      echo $'  = '[\(in function-level operations\)]
      echo $'  0 '[\<-IN: back through call chain]
      echo
      echo [OUT] $trace [IN]
      echo
    };
}

function call() {

  (( $# == 0 )) && {
    echo $COMMAND: error: invalid call: "no parameters were specified for the call with: ${trace/*<- /}";
    exit 1;
  } >&2;
  
  local name trace=${trace}
  [[ "$1" != trace ]] && trace+=" <- $1";
  [[ $DEBUG == 1 ]] && {  
    key-within-list "$1" -- $(echo $FUNCTIONS) && dump.trace
  }  >&2;

  key-within-list "$1" -- $OPTIONS $FUNCTIONS $DEBUG_FUNCTIONS && { 
    "$@"; exit $?; 
  };
  
  declare -A parse;
  opkit.begin CONFIG;

  opkit.parse CONFIG parse "$@" || {
    echo "$COMMAND parameter parse error: code: $?: parameter #${parse[POINT]} didn't parse" >&2;
    opkit.dump parse;
    exit $code;
  }
  
  (( parse[BRANCH] > 5 )) && {
    local cmd="-${parse[PARAMETER]}";
    (( parse[SIZE] == 2 )) && cmd+=":";
    if [[ -n "${parse[VALUE]}" ]]; then
      $cmd: "${parse[VALUE]}" "${@:2}"; exit $?;    
    else
      $cmd -${parse[INPUT]:2} "${@:2}"; exit $?;
    fi;
  }
  
  (( DEBUG )) && opkit.dump parse;

  {
    echo invalid command: "\`$1'";
    echo "type: $COMMAND --help or $COMMAND -h for $COMMAND help";
    exit 1;
  }  >&2;
  
}

function --help() {

cat <<EOF

$COMMAND [OPTIONS] FUNCTION [...]

General Purpose, Mutliple Record, File and String: Utility

 ALL EXPRESSIONS, REGULARLY: EXTENDED.

License: MIT
GitHub: https://github.com/hypersoft/x-director

(C) 2018; Triston-Jerard: Taylor;
          Hypersoft-Systems: U.-S.-A.

OPTION FLAGS

 Flags may be combined to produce a compound option. For example:

   $COMMAND -rf catalog -d 1 -- .

   Lists the real path of files in the current directory.

 --help  Show this help screen
  -h      Show this help screen.

 --get-theatre  Generates a hash-key-list of FUNCTIONS and OPTIONS.

 -r  Convert path record(s) to realpath(s).
 -d  Only print existing directories.
 -f  Only print existing files.
 -p  Only print parent directories.
 -l  Only print links.
 -L  Do not print links.
 -n  Only print file names.

OPTION FLAGS: ENVIRONMENT

  -z  Set Standards Compliant IFS = \$' \t\n'.
  -t  Match the tail/type of records. Uses the RX char: \`\$'
  -h  Match the head/heading of records. Uses the RX char: \`^'

OPTION SETTINGS

 Settings may be combined with flags as a single parameter, IF: it is the last
 OPTION in the single-parameter-set. For example:
 
   $COMMAND -ti:\.md -f catalog -d 1 -- .

   Lists all .md files in the current directory.

 -e: FILTER   Perform an exclude match against FILTER(s). Multiple filters may
              be supplied as a single parameter. The shell will expand the
              FILTERS according to IFS (see also OPTIONS: \`-z': and \`-z') for
              control of the shell expansion.

 -i: FILTER   Perform an include match against FILTER(s). Works like \`-e:'.

 -s: TYPE     Perform a sort by TYPE; where TYPE is:

               u for uniqe sort.
               v for version sort.
               n for name sort.
               
               [TYPES cannot be combined as a single parameter to \`-s:']

OPTION SETTINGS: EVIRONMENT
 
 -t: TEXT     Sets the TAIL of all primary expressions to text.
 -h: TEXT     Sets the HEAD of all primary expressions to TEXT.

 -Q: TEXT     Sets the internal expression separator of the subset FUNCTION
              to TEXT. You may never need this option. The default is \$'\1'.
              This feature only affects the subset FUNCTION.

 -q: TEXT     Set regular-expression quoting character to TEXT for internal
              scripts. The default is \`'".

 -z: TEXT     Sets the IFS variable to TEXT. See your shell manual about IFS.

FUNCTIONS

 catalog [-d NUMBER] -- DIRECTORY [...]
 
   Lists the files in DIRECTOR(IES). If option -d is supplied, it limits the
   maximum depth of the search; where 1 means do not traverse any children of
   the DIRECTORY; 2 is children of child DIRECTORY, so on and so forth.

 directories FILE ...     Lists only the directories in FILE(S).
 files FILE ...           Lists only the file(s) in FILE(S).

 filter [-e] -- MATCH-PATTERN ...

  Searches through stdin line records seeking MATCH-PATTERN(S). If MATCH-PATTERN
  is found it is written to stdout unless the -e option has been specified. If
  the -e option has been specified, all matches are excluded from output.

 names FILE ...           Lists only the name parts of FILE(S).
 parents FILE ...         Lists only the parent-directories of FILE(S).

 links [-e] -- FILE ...   Lists only the links in FILE(S). With \`-e', lists
                          all files which are NOT links.

 read-parameter-pipe  COMMAND or FUNCTION [OPTIONS]

   Read lines from input and send them as parameters to COMMAND or FUNCTION
   with any OPTIONS.

 write-parameter-pipe  ...  Converts all parameters to line-stream-output.

 trace SOMETHING     Performs a debug trace explaining dependency chain,
                     backwards AND forwards [quantum-filters ;)].
                     
 realpaths FILE ...       List only the realpath(s) of FILE(S).

 key-within-list KEY -- VALUE ...

   Searches through VALUE(S) for KEY. Returns success if literally found. Ready
   made for read-parameter-pipe  FUNCTION.

 subset CUT-PATTERN PASTE-TEXT[ CUT-PATTERN PASTE-TEXT[ ...]]

   Searches through stdin line records using CUT-PATTERN and replaces matches
   with PASTE-TEXT. Multiple CUT-PATTERN and PASTE-TEXT expressions may be
   supplied. Use the write-parameter-pipe FUNCTION if stdio is not convenient.

NOTE:

 (1) OPTIONS affect the output of FUNCTIONS.

 (2) OPTIONS are executed in REVERSE-ORDER of command specification; except:
     (1) when an OPTION is not a shortcut to a FUNCTION.
         (1.a) if the OPTION is not a shortcut to a FUNCTION, it is instantly
               applied THROUGH the OPTION or FUNCTION following it in the
               command specification. Which means all environment OPTIONS are
               immediately effective at the beginning of the command following
               it; being of the form: [ENVIRONMENT] OPTION OR FUNCTION.

               [see: the function definitions of the OPTIONS in source code
                     to verify the above form.
                
                  file://$(realpath $0)
               ]

See: "regex - POSIX.2 regular expressions" within the Linux Programmer's Manual
     for help on expressions with and without the -E OPTION.

END $COMMAND --help ############################################################

$COMMAND [OPTIONS] FUNCTION [...]

General Purpose, Mutliple Record, File and String: Utility

 ALL EXPRESSIONS, REGULARLY: EXTENDED.

License: MIT
GitHub: https://github.com/hypersoft/x-director

                                           (C) 2018; Triston-Jerard: Taylor;
                                                     Hypersoft-Systems: U.-S.-A.

EOF

exit 1;

} >&2;

trace='' call "$@";

TODO:

  table, rows, columns

  join, split

  modify case
  
  mask expression
  
  let function be any command
  
  Lesser used functions, having no short-cuts.
  
  shamelessly snatch some string functions from GNU make
  
  help section about regular: regular expressions -- lol and extended regular
  expressions.

