#!/bin/bash

set -e;

IFS=$' \t\n'; # do no dummy stuff

COMMAND=$(basename $0); # smart stuff is ok
BAD_SUBST_PARAMS="wrong number of parameters: expected pattern and replacement parameter pairs following data"

function subset.script() {

  local head=${head:-''} tail=${tail:-''} split=${split:-$'\1'} quote=${quote:-"'"};

  (( $# % 2 || $# == 0 )) && {
    echo
    echo $COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS: an invalid number of substitution specifications were provided.
    echo
    echo $'\t'try: $COMMAND $FUNCNAME \"DATA-INPUT\" MATCH-PATTERN REPLACEMENT-TEXT[, MATCH-PATTERN REPLACEMENT-TEXT[, ...]]
    echo
    exit 1;
  } >&2;
  echo -n sed $flags;
  while (( $# )); do printf " -e ${quote}s%sg${quote}" "${split}${head}${1}${tail}${split}${2}${split}"; shift 2; done;
  echo ';'
}

function pipe() {
  local pre= cmd=$1; shift;
  [[ "$cmd" == links && $1 == -e ]] && {
    pre=-e; shift;
  }
  [[ "$cmd" == filter  || $cmd == subset ]] && {
    $cmd "$(</dev/stdin)" "${@}";
    return;
  }
  $cmd $pre $(</dev/stdin) "${@}";
}

function subset() {

  (( $# == 0 )) && {
    echo $COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS: 0 parameters were provided.
    echo try: $COMMAND $FUNCNAME \"DATA-INPUT\" MATCH-PATTERN REPLACEMENT-TEXT
    exit 1;
  } >&2;

  local content="$1"; shift;

  [[ "$content" =~ ^$ ]] && {
    echo $COMMAND: $FUNCNAME: error: no data was given\; aborting
    exit 1;
  } >&2;

  # the following parameters are paired in twos:
  # $1 find-pattern, $2 replacement[, ...]
  # this format allows you to perform successive substitutions in a reliable way.

  (( $# % 2 )) && {
    echo $COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS: an odd number of substitution specifications were provided.
    echo try: $COMMAND $FUNCNAME \"DATA-INPUT\" MATCH-PATTERN REPLACEMENT-TEXT[, MATCH-PATTERN REPLACEMENT-TEXT[, ...]]
    exit 1;
  } >&2;
  source <(subset.script "$@") < <(printf "%s\n" "$content");
}

function filter.script() {
    local head=${head:-''} tail=${tail:-''} quote=${quote:-"'"};
    [[ "$1" == -e ]] && local flags+=' -v';
    echo -n grep $flags; 
    while (( $# )); do printf " -e ${quote}${head}%s${tail}${quote}" "$1"; shift; done; 
    echo ';';  
}

function filter() {
  local content="$1"; shift;
  source <(filter.script "$@") < <(printf "%s\n" "$content");
}

function catalog() {
  local dir= file=
  if [[ "$d" == '' ]]; then local -i d=0; fi;
  d=$d+1;
  (( max > 0 && d > max )) && return;      
  for dir; do
    for file in "${dir%/}"/*; do
      [ -e "$file" ] || [ -L "$file" ] || continue
      if [ -d "$file" ]; then
        printf "%s\n" "$file"
        catalog "$file"
      else
        printf "%s\n" "$file"
      fi
    done
  done;
}

function realpaths() {
  for arg; do realpath "$arg" || continue; done;
  true;
}

function parents() {
  for arg; do
    [[ $arg == / ]] && continue;
    dirname "$arg" || continue;
  done;
  true;
}

function names() {
  for arg; do
    [[ $arg == / ]] && continue;
    basename "$arg" || continue; 
  done;
  true;
}

function files() {
  for file; do [[ -d "$file" ]] && continue; [[ -e "$file" ]] && echo "$file"; done;
  true;
}

function links() {
  [[ $1 == -e ]] && {
    shift;
    for file; do
      if [[ -h "$file" ]]; then continue; fi;
      echo $file;
    done;
    return 0;
  }
  for file; do
    if [[ -h "$file" ]]; then echo $file; fi;
  done;
  true;
}

function directories() {
  for file; do 
    if [[ -d $file ]]; then echo "$file"; fi;
  done;
  true;
}

function key-within-list() { # make sure you test this result in error-mode-shells
  # suitable with pipe's default to-program-input format.  
  local -i l=$[ $# - 1 ];
  local key="${@:$#:1}";
  set -- "${@:0:$#}";
  for item; do
   [[ "$item" == "$key" ]] && {
     return 0;
   }
  done
  return 1;
}

function -e:() { # runs exclusive filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | flags+=' -v' pipe filter $1;
}

function -i:() { # runs inclusive regular expression filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | pipe filter $1;
}

function -l:() { # catalog depth limit
  max=$1 call "${@:2}";
}

function -f() { # filters content by existing files
  call "$@" | pipe files;
}

function -d() { # filters content by existing directories
  call "$@" | pipe directories;
}

function -z() { # reset IFS
  IFS=$' \t\n' call "$@";
}

function -z:() { # sets IFS: PARAMETER
  IFS=$1 call "${@:2}";
}

function -E() { # extended regular expressions - lol
  flags='-E' call "$@";
}

function -R() {
  call "$@" | pipe realpaths;
}

function -l() {
  call "$@" | pipe links;
}

function -L() {
  call "$@" | pipe links -e;
}

function -p() {
  call "$@" | pipe parents;
}

function -q:() {
  quote=$1 call "${@:2}";
}

function -Q:() { # this option only affects subset
  split=$1 call "${@:2}";
}

function -TH() {
  tail=\$ head=\^ call "$@";
}

function -HT() {
  tail=\$ head=\^ call "$@";
}

function -T() {
  tail=\$ call "${@}";
}

function -T:() {
  tail=$1 call "${@:2}";
}

function -H() {
  head=\^ call "${@}";
}

function -H:() {
  head=$1 call "${@:2}";
}

function -O:() {
  flags=$1 call "${@:2}";
}

function dump.function.table() {
  local all="$(env -i DEBUG=1 $0 declare -pF | flags='-v' pipe filter '\.' | cut -d ' ' -f3)"
  echo OPTIONS=\"$(filter "$all" '^-')\"\;;
  echo FUNCTIONS=\"$(filter "$all" -e '^-' '^call$')\"\;;
}

function --get-theatre() {
  dump.function.table;
}

function -h() {
  --help "$@";
}

function --help() {

cat <<EOF

$COMMAND [OPTIONS] FUNCTION [...]

General Purpose, Mutliple Record, File and String: Utility

License: MIT
GitHub: https://github.com/hypersoft/mapkit

(C) 2018; Triston-Jerard: Taylor;
          Hypersoft-Systems: U.-S.-A.

OPTION FLAGS

 --help  Show this help screen
 -h      Show this help screen.

 --get-theatre  Generates a hash-key-list of FUNCTIONS and OPTIONS. [DEBUG]

 -E  Turn on extended regular expression features for the subset and filter
     FUNCTIONS. This flag overrides OPTION \`-e'.

 -R  Convert path record(s) to realpath(s).
 -d  Only print existing directories.
 -f  Only print existing files.
 -p  Only print parent directories.
 -l  Only print links.
 -L  Do not print links.
 -n  Only print file names.
 -z  Set Standards Compliant IFS = \$' \t\n'
 -T  Match the tail/type of records. Uses the RX char: \`\$'
 -H  Match the head/heading of records. Uses the RX char: \`^'

 NOTE: 

 (1) Combining \`-H' and \`-T' has the effect of matching: \`^...$'; where ...
     is your primary-expression.

OPTION SETTINGS

 -T: TEXT     Sets the TAIL of all primary expressions to text.
 -H: TEXT     Sets the HEAD of all primary expressions to TEXT.
 -O: OPTIONS  Sets the main OPTIONS to pass to both sed and grep to OPTIONS.

 -Q: TEXT     Sets the internal expression separator of the subset FUNCTION
              to TEXT. You may never need this option. The default is \$'\1'.
              This feature only affects the subset FUNCTION.

 -e: FILTER   Perform an exclude match against FILTER(s). Multiple filters may
              be supplied as a single parameter. The shell will expand the
              FILTERS according to IFS (see also OPTIONS: \`-z': and \`-z') for
              control of the shell expansion.

 -i: FILTER   Perform an include match against FILTER(s). Works like \`-e:'.
 -l: NUMBER   Sets the max-depth of the catalog FUNCTION to NUMBER.
 
 -q: TEXT     Set regular-expression quoting character to TEXT for internal
              scripts. This feature only affects primary expressions.
 
 -z: TEXT     Sets the IFS variable to TEXT. See your shell manual about IFS.

FUNCTIONS

 NOTE: most FUNCTIONS have shortcuts in the OPTIONS section for advanced use.

 catalog DIRECTORY [...]  Lists the files in directories.
 directories FILE ...     Lists only the directories in FILE(S).
 files FILE ...           Lists only the file(s) in FILE(S).

 filter DATA [-e] FIND-PATTERN ...
                
  Finds FIND-PATTERN in the input records, and excludes or includes the record.
  the default operation is include. use option \`-e' to exclude. Using \`-e'
  with this FUNCTION is different than using OPTION \`-e:'. Using \`-e' 
  with this FUNCTION does not require multiple filters as a single argument.
  The first FIND-PATTERN cannot be: \`-e'.

 names FILE ...           Lists only the name parts of FILE(S).
 parents FILE ...         Lists only the parent-directories of FILE(S).

 links [-e] FILE ...      Lists only the links in FILE(S). With \`-e', lists
                          all files which are NOT links. The first FILE cannot
                          be: \`-e'.

 pipe FUNCTION ...        Reads the standard input and sends it as the data
                          portion of FUNCTION OR COMMAND, forwarding all
                          remaining parameters to the FUNCTION OR COMMAND.

 trace SOMETHING     Performs a debug trace explaining dependency chain,
                     backward AND forward [quantum-filters ;)].
                     
 realpaths FILE ...       List only the realpath(s) of FILE(S).

 key-within-list VALUES... KEY  
 
   Searches through values for key. Returns success if literally found. Ready
   made for pipe FUNCTION.

 subset DATA FIND-PATTERN REPLACE-TEXT ...

NOTE:

 (1) OPTIONS affect the output of FUNCTIONS.

 (2) OPTIONS are executed in REVERSE-ORDER of command specification; except:
     (1) when an OPTION is not a shortcut to a FUNCTION.
         (1.a) if the OPTION is not a shortcut to a FUNCTION, it is instantly
               applied THROUGH the OPTION or FUNCTION following it in the
               command specification. Which means all environment OPTIONS are
               immediately effective at the beginning of the command following
               it; being of the form: [ENVIRONMENT] OPTION OR FUNCTION.

               [see: the function definitions of the OPTIONS in source code
                     to verify the above form.
                
                  file://$(realpath $0)
               ]
               
 (3) Separate FUNCTION OPTIONS using the pipe FUNCTION in conjunction with
     shell pipes. Combining multiple options in the wrong way may cause
     undesired operations.

END $COMMAND --help ############################################################

$COMMAND [OPTIONS] FUNCTION [...]

General Purpose, Mutliple Record, File and String: Utility

License: MIT
GitHub: https://github.com/hypersoft/mapkit

                                           (C) 2018; Triston-Jerard: Taylor;
                                                     Hypersoft-Systems: U.-S.-A.

EOF

exit 1;

}

OPTIONS="--get-theatre --help -E -H -H: -HT -L -O: -Q: -R -T -T: -TH -d -e: -f -h -i: -l -l: -p -q: -z -z:";
FUNCTIONS="catalog directories files filter key-within-list links names parents pipe realpaths subset trace ";

(( DEBUG == 1 )) && {
  DEBUG_FUNCTIONS="declare dump.function.table filter.script subset.script";
}

function trace() {
  DEBUG=1 call "$@";
}

function call() {
  local name trace=${trace}
  [[ "$1" != trace ]] && trace+=" <- $1";
  [[ $DEBUG == 1 ]] && {  
    key-within-list $(echo $FUNCTIONS) "$1" && {
      echo
      echo $command trace: 
      echo
      echo $'  0 '[:OUT-\>]
      echo  '  + '[compile]
      echo $'  1 'read OPTIONS left to right, for logical [dependency] order
      echo $'  + '[direction-flip]
      echo $' -1 'read right to left for output [composition] order.
      echo $'  = '[\(in function-level operations\)]
      echo $'  0 '[\<-IN: back through call chain]
      echo
      echo [OUT] $trace [IN]
      echo
    } >&2;
  }
  key-within-list $OPTIONS $FUNCTIONS $DEBUG_FUNCTIONS "$1" && { 
    "$@"; exit $?; 
  }
  {
    echo invalid command: "\`$1'";
    echo type: $COMMAND --help or $COMMAND -h for $COMMAND help;
    exit 1;
  }  >&2;
}

trace='' call "$@";

TODO:

  OPTION -t and FUNCTION trace -- user level tracing
  NON-SETTING OPTION MASHUPS IE -ERd ... == (set flags=-E; pipe directories | pipe realpaths)
  NON-SETTING OPTION MASHUP ENDING WITH OPTION SETTING
  Lesser used functions, having no short-cuts.
  Better call tracing parameter display.
  
  RESTRICT grep and sed OPTIONS to -E -v and EMPTY only to take the stress off
  of porting. OTHER DECLARED availabilities such as sed -i are bonus. Not having
  an interface defined makes porting in future time nightmarish.
  
  help section about regular: regular expressions -- lol and extended regular
  expressions.
  
  
