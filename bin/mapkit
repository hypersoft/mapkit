#!/bin/bash

set -e;

IFS=$' \t\n'; # do no dummy stuff

COMMAND=$(basename $0);
BAD_SUBST_PARAMS="wrong number of parameters: expected pattern and replacement pairs following data"

function subset.script() {

  local head=${head:-''} tail=${tail:-''} split=${split:-$'\1'} quote=${quote:-"'"};

  (( $# % 2 || $# == 0 )) && {
    echo
    echo $COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS: an invalid number of substitution specifications were provided.
    echo
    echo $'\t'try: $COMMAND $FUNCNAME \"DATA-INPUT\" MATCH-PATTERN REPLACEMENT-TEXT[, MATCH-PATTERN REPLACEMENT-TEXT[, ...]]
    echo
    exit 1;
  } >&2;
  echo -n sed $flags;
  while (( $# )); do printf " -e ${quote}s%sg${quote}" "${split}${head}${1}${tail}${split}${2}${split}"; shift 2; done;
  echo ';'
}

function pipe() {
  local pre= cmd=$1; shift;
  [[ "$cmd" == links && $1 == -e ]] && {
    pre=-e; shift;
  }
  [[ "$cmd" == filter  || $cmd == subset ]] && {
    $cmd "$(</dev/stdin)" "${@}";
    return;
  }
  $cmd $pre $(</dev/stdin) "${@}";
}

function subset() {

  (( $# == 0 )) && {
    echo $COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS: 0 parameters were provided.
    echo try: $COMMAND $FUNCNAME \"DATA-INPUT\" MATCH-PATTERN REPLACEMENT-TEXT
    exit 1;
  } >&2;

  local content="$1"; shift;

  [[ "$content" =~ ^$ ]] && {
    echo $COMMAND: $FUNCNAME: error: no data was given\; aborting
    exit 1;
  } >&2;

  # the following parameters are paired in twos:
  # $1 find-pattern, $2 replacement[, ...]
  # this format allows you to perform successive substitutions in a reliable way.

  (( $# % 2 )) && {
    echo $COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS: an odd number of substitution specifications were provided.
    echo try: $COMMAND $FUNCNAME \"DATA-INPUT\" MATCH-PATTERN REPLACEMENT-TEXT[, MATCH-PATTERN REPLACEMENT-TEXT[, ...]]
    exit 1;
  } >&2;
  source <(subset.script "$@") < <(printf "%s\n" "$content");
}

function filter.script() {
    local head=${head:-''} tail=${tail:-''} quote=${quote:-"'"};
    [[ "$1" == -e ]] && local flags+=' -v';
    echo -n grep $flags; 
    while (( $# )); do printf " -e ${quote}${head}%s${tail}${quote}" "$1"; shift; done; 
    echo ';';  
}

function filter() {
  local content="$1"; shift;
  source <(filter.script "$@") < <(printf "%s\n" "$content");
}

function catalog() {
  local dir= file=
  if [[ "$d" == '' ]]; then local -i d=0; fi;
  d=$d+1;
  (( max > 0 && d > max )) && return;      
  for dir; do
    for file in "${dir%/}"/*; do
      [ -e "$file" ] || [ -L "$file" ] || continue
      if [ -d "$file" ]; then
        printf "%s\n" "$file"
        catalog "$file"
      else
        printf "%s\n" "$file"
      fi
    done
  done;
}

function realpaths() {
  for arg; do realpath "$arg" || continue; done;
  true;
}

function parents() {
  for arg; do
    [[ $arg == / ]] && continue;
    dirname "$arg" || continue;
  done;
  true;
}

function names() {
  for arg; do
    [[ $arg == / ]] && continue;
    basename "$arg" || continue; 
  done;
  true;
}

function files() {
  for file; do [[ -d "$file" ]] && continue; [[ -e "$file" ]] && echo "$file"; done;
  true;
}

function links() {
  [[ $1 == -e ]] && {
    shift;
    for file; do
      if [[ -h "$file" ]]; then continue; fi;
      echo $file;
    done;
    return 0;
  }
  for file; do
    if [[ -h "$file" ]]; then echo $file; fi;
  done;
  true;
}

function directories() {
  for file; do 
    if [[ -d $file ]]; then echo "$file"; fi;
  done;
  true;
}

function -e:() { # runs exclusive filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | flags+=' -v' pipe filter $1;
}

function -i:() { # runs inclusive regular expression filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | pipe filter $1;
}

function -l:() { # catalog depth limit
  max=$1 call "${@:2}";
}

function -f() { # filters content by existing files
  call "$@" | pipe files;
}

function -d() { # filters content by existing directories
  call "$@" | pipe directories;
}

function -z() { # reset IFS
  IFS=$' \t\n' call "$@";
}

function -z:() { # sets IFS: PARAMETER
  IFS=$1 call "${@:2}";
}

function -E() { # extended regular expressions - lol
  flags='-E' call "$@";
}

function -R() {
  call "$@" | pipe realpaths;
}

function -l() {
  call "$@" | pipe links;
}

function -L() {
  call "$@" | pipe links -e;
}

function -p() {
  call "$@" | pipe parents;
}

function -q:() {
  quote=$1 call "${@:2}";
}

function -Q:() { # this option only affects subset
  split=$1 call "${@:2}";
}

function -TH() {
  tail=\$ head=\^ call "$@";
}

function -HT() {
  tail=\$ head=\^ call "$@";
}

function -T() {
  tail=\$ call "${@:2}";
}

function -T:() {
  tail=$1 call "${@:2}";
}

function -H() {
  head=\^ call "${@:2}";
}

function -H:() {
  head=$1 call "${@:2}";
}

function -O:() {
  flags=$1 call "${@:2}";
}

function dump.function.table() {
  local all="$(env -i DEBUG=1 $0 declare -pF | flags='-v' pipe filter '\.' | cut -d ' ' -f3)"
  echo OPTIONS=\"$(filter "$all" '^-')\"\;;
  echo FUNCTIONS=\"$(filter "$all" -e '^-' '^call$')\"\;;
}

function get-theatre() {
  dump.function.table;
}

function -h() {
  --help "$@";
}

function --help() {

cat <<EOF

General Purpose, Mutliple Record, File and String: Utility

$COMMAND [OPTIONS] FUNCTION [...]

OPTION FLAGS

 --help  Show this help screen
 -h      Show this help screen.

 get-theatre  Debug OPTION. Generates a hash-key-list of FUNCTIONS and OPTIONS.

 -E  Turn on extended regular expression features for the subset and filter
     FUNCTIONS. This flag overrides OPTION \`-e'.

 -R  Convert path record(s) to realpath(s).
 -d  Only print existing directories.
 -f  Only print existing files.
 -p  Only print parent directories.
 -l  Only print links.
 -L  Do not print links.
 -n  Only print file names.
 -z  Set Standards Compliant IFS = \$' \t\n'
 -T  Match the tail/type of records. Uses the RX char: \`\$'
 -H  Match the head/heading of records. Uses the RX char: \`^'

 NOTE: 

 (1) Combining \`-H' and \`-T' has the effect of matching: \`^...$'; where ...
     is your primary-expression.

OPTION SETTINGS

 -T: TEXT     Sets the TAIL of all primary expressions to text.
 -H: TEXT     Sets the HEAD of all primary expressions to TEXT.
 -O: OPTIONS  Sets the main OPTIONS to pass to both sed and grep to OPTIONS.

 -Q: TEXT     Sets the internal expression separator of the subset FUNCTION
              to TEXT. You may never need this option. The default is \$'\1'.
              This feature only affects the subset FUNCTION.

 -e: FILTER   Perform an exclude match against FILTER(s). Multiple filters may
              be supplied as a single parameter. The shell will expand the
              FILTERS according to IFS (see also OPTIONS: \`-z': and \`-z') for
              control of the shell expansion.

 -i: FILTER   Perform an include match against FILTER(s). Works like \`-e:'.
 -l: NUMBER   Sets the max-depth of the catalog FUNCTION to NUMBER.
 
 -q: TEXT     Set regular-expression quoting character to TEXT for internal
              scripts. This feature only affects primary expressions.
 
 -z: TEXT     Sets the IFS variable to TEXT. See your shell manual about IFS.

FUNCTIONS

 NOTE: most FUNCTIONS have shortcuts for advanced use in the option section.

 catalog DIRECTORY [...]  Lists the files in directories.
 directories FILE ...     Lists only the directories in FILE(S).
 files FILE ...           Lists only the file(s) in FILE(S).

 filter DATA [-e] FIND-PATTERN ...
                
  Finds FIND-PATTERN in the input records, and excludes or includes the record.
  the default operation is include. use option \`-e' to exclude. Using \`-e'
  with this FUNCTION is different than using OPTION \`-e:'. Using \`-e' 
  with this FUNCTION does not require multiple filters as a single argument.
  The first FIND-PATTERN cannot be: \`-e'.

 names FILE ...           Lists only the name parts of FILE(S).
 parents FILE ...         Lists only the parent-directories of FILE(S).

 links [-e] FILE ...      Lists only the links in FILE(S). With \`-e', lists
                          all files which are NOT links. The first FILE cannot
                          be: \`-e'.

 pipe FUNCTION ...        Reads the standard input and sends it as the data
                          portion of FUNCTION OR COMMAND, forwarding all
                          remaining parameters to the FUNCTION OR COMMAND.

 realpaths FILE ...       List only the realpath(s) of FILE(S).

 subset DATA FIND-PATTERN REPLACE-TEXT ...

NOTE:

 (1) OPTIONS affect the output of FUNCTIONS.
 (2) OPTIONS are precedented in REVERSE-ORDER.
 (3) Separate FUNCTION OPTIONS using the pipe FUNCTION in conjunction with
     shell pipes. Combining multiple options in the wrong way may cause
     undesired operations.

EOF

exit 1;

}

OPTIONS="--help -E -H -H: -HT -L -O: -Q: -R -T -T: -TH -d -e: -f -h -i: -l -l: -p -q: -z -z:"
FUNCTIONS="catalog directories files filter get-theatre links names parents pipe realpaths subset";

(( DEBUG == 1 )) && {
  DEBUG_FUNCTIONS="declare dump.function.table filter.script subset.script";
}

function call() {
  local name trace="$1: "${trace};
   [[ $DEBUG == 1 ]] && {  
    for name in $FUNCTIONS; do
      [[ $1 == $name ]] && echo $trace >&2;
    done;
  }
  for name in $OPTIONS $FUNCTIONS $DEBUG_FUNCTIONS; do
    [[ $1 == $name ]] && { "$@"; exit $?; }
  done;
  {
  echo invalid command: "\`$1'";
  echo type: $COMMAND --help or $COMMAND -h for $COMMAND help;
  exit 1;
  }  >&2;
}

trace='' call "$@";

