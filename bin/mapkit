#!/bin/bash

set -e;

IFS=$' \t\n'; # do no dummy stuff

COMMAND=$(basename $0); # smart stuff is ok

BAD_SUBST_PARAMS="wrong number of parameters; expected pattern and replacement parameter-pairs following options"

function subset.script() {

  local head=${head:-''} tail=${tail:-''} split=${split:-$'\1'} quote=${quote:-"'"} flags=-E;

  # the following parameters are paired in twos:
  # $1 find-pattern, $2 replacement[, ...]
  # this format allows you to perform successive substitutions in a reliable way.

  (( $# % 2 || $# == 0 )) && {
    echo
    echo $COMMAND: ${FUNCNAME[1]}: error: $BAD_SUBST_PARAMS: an invalid number of substitution specifications were provided.
    echo
    echo $'\t'try: $COMMAND ${FUNCNAME[1]} CUT-PATTERN PASTE-TEXT[, CUT-PATTERN PASTE-TEXT[, ...]]
    echo
    exit 1;
  } >&2;

  echo -n sed $flags;
  while (( $# )); do printf " -e ${quote}s%sg${quote}" "${split}${head}${1}${tail}${split}${2}${split}"; shift 2; done;
  echo ';'

}

function filter.script() {

    local head=${head:-''} tail=${tail:-''} quote=${quote:-"'"} flags=-E;

    [[ "$1" == -e ]] && { # for invert match == '-e[xclude]'
      flags+=" -v"; shift;
    }

    [[ "$1" == -- ]] || {
      echo
      echo "$COMMAND: ${FUNCNAME[1]}: error: match specifications must be preceded by \`--' for disambiguation of matches and match options"
      echo
      exit 1;
    } >&2;
    
    shift;
    
    echo -n grep $flags;
    while (( $# )); do printf " -e ${quote}${head}%s${tail}${quote}" "$1"; shift; done; 
    echo ';';
    
}

function subset() {

  local content=

  (( $# == 0 )) && {
    echo
    echo "$COMMAND: $FUNCNAME: error: $BAD_SUBST_PARAMS; 0 parameters were provided"
    echo
    echo $'\t'try: $COMMAND $FUNCNAME CUT-PATTERN PASTE-TEXT[ CUT-PATTERN PASTE-TEXT[ ...]]
    echo
    exit 1;
  } >&2;

  source <(subset.script "$@");

}

BAD_FILTER_PARAMS="wrong number of parameters; expected pattern-match(es) following options"

function filter() {

  (( $# == 0 )) && {
    echo
    echo "$COMMAND: $FUNCNAME: error: $BAD_FILTER_PARAMS; 0 parameters were provided"
    echo
    echo $'\t'try: $COMMAND $FUNCNAME [OPTIONS] -- MATCH-PATTERN ...
    echo
    exit 1;
  } >&2;

  source <(filter.script "$@");

}

function write-parameter-pipe () {
  printf "%s\n" "$@";
}

function read-pipe-parameters() {
  local lines;
  readarray lines;
  "$@" "${lines[@]%$'\n'}";
}

function catalog() {

  [[ $1 == -m ]] && {
    local -i max=$2; shift 2;
  }

  [[ "$1" == -- ]] || {
    echo
    echo "$COMMAND: ${FUNCNAME}: error: directory names must be preceeded by \`--' for disambiguation of options and files"
    echo
    echo $'\t'try: $COMMAND ${FUNCNAME} [-m NUMBER] -- DIRECTORY ...
    echo
    exit 1;
  } >&2;

  shift;

  local dir= file=

  if [[ "$d" == '' ]]; then local -i d=0; fi;
  d=$d+1;
  (( max > 0 && d > max )) && return;      
  for dir; do
    for file in "${dir%/}"/*; do
      [ -e "$file" ] || [ -L "$file" ] || continue
      if [ -d "$file" ]; then
        printf "%s\n" "$file"
        catalog -- "$file"
      else
        printf "%s\n" "$file"
      fi
    done
  done;
  
}

function realpaths() {
  for arg; do realpath "$arg" || continue; done;
  true;
}

function parents() {
  for arg; do
    [[ $arg == / ]] && continue;
    dirname "$arg" || continue;
  done;
  true;
}

function names() {
  for arg; do
    [[ $arg == / ]] && continue;
    basename "$arg" || continue; 
  done;
  true;
}

function files() {
  for file; do [[ -d "$file" ]] && continue; [[ -e "$file" ]] && echo "$file"; done;
  true;
}

function links() {

  local -i include=1;
  
  [[ "$1" == -e ]] && { include=0; shift; }
  
  [[ "$1" == -- ]] || {
    echo
    echo "$COMMAND: ${FUNCNAME}: error: file specifications must be preceded by \`--' for disambiguation of files and options"
    echo
    echo $'\t'try: $COMMAND ${FUNCNAME[1]} [-e] -- FILE ...
    echo
    exit 1;
  } >&2;
  
  shift;
  
  (( include )) && {
    for file; do
      if [[ -h "$file" ]]; then 
        echo "$file";
      fi;
    done;
    return 0;
  }
  
  for file; do
    if [[ -h "$file" ]]; then continue; fi;
    echo "$file";
  done;
  
  return 0;
  
}

function directories() {
  for file; do 
    if [[ -d $file ]]; then echo "$file"; fi;
  done;
  true;
}

function key-within-list() { # make sure you test this result in error-mode-shells
  # suitable with pipe's default to-program-input format.  
  local key="${@:$#:1}";
  set -- "${@:0:$#}";
  for item; do
   [[ "$item" == "$key" ]] && {
     return 0;
   }
  done
  return 1;
}

function -e:() { # runs exclusive filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | filter -e -- $1;
}

function -i:() { # runs inclusive regular expression filter; matches should be seprated by IFS[0-2]
  call "${@:2}" | filter -- $1;
}

function -f() { # filters content by existing files
  call "$@" | read-pipe-parameters files;
}

function -d() { # filters content by existing directories
  call "$@" | read-pipe-parameters directories;
}

function -z() { # reset IFS
  IFS=$' \t\n' call "$@";
}

function -z:() { # sets IFS: PARAMETER
  IFS=$1 call "${@:2}";
}

function -r() {
  call "$@" | read-pipe-parameters realpaths;
}

function -l() {
  call "$@" | read-pipe-parameters links --;
}

function -L() {
  call "$@" | read-pipe-parameters links -e --;
}

function -p() {
  call "$@" | read-pipe-parameters parents;
}

function -s() {
  -s: n "$@";
}

function -s:() {
  [[ $1 == u ]] && {
    shift;
    call "$@" | uniq;
    return;
  }
  [[ $1 == v ]] && {
    shift;
    call "$@" | sort -V;
    return;
  }
  [[ $1 == n ]] && {
    shift;
    call "$@" | sort;
    return;
  }
  echo "$COMMAND: error: no sorting solution found for: $1";
  exit 1;
}

function -q:() {
  quote=$1 call "${@:2}";
}

function -Q:() { # this option only affects subset
  split=$1 call "${@:2}";
}

function -t() {
  tail=\$ call "${@}";
}

function -t:() {
  tail=$1 call "${@:2}";
}

function -h:() {
  head=$1 call "${@:2}";
}

function dump.function.table() {
  local all="$(env -i DEBUG=1 $0 declare -pF | filter -e -- '\.' | cut -d ' ' -f3)"
  echo OPTIONS=\"$(write-parameter-pipe  "$all" | filter -- '^-')\";
  echo FUNCTIONS=\"$(write-parameter-pipe  "$all" | filter -e -- '^-' '^call$')\";
}

function --get-theatre() {
  dump.function.table;
}

function -h() {
  (( $# == 0 )) && {
    --help
  }
  head=\^ call "${@}";
}

function trace() {
  DEBUG=1 call "$@";
}

function parseopt.match() {
  local match="$1"; shift;
  for param; do [[ "$match" == "$param" ]] && return 0; done;
  return 1;
}

function parseopt.keys() {
  eval echo \${!$1[@]}\;;
}

function parseopt.set() {
  local destination=$1 assignment; shift;
  for assignment; do
    local key="${assignment/=*/}";
    local value="${assignment/*=/}"
    printf -v ${destination}$key %s "$value"
  done;
}

function parseopt.get() {
  local source=$1 name; shift;
  for name; do
    eval echo \${$source[$name]}\;;
  done;
}

function parseopt.content() {
  eval echo \${$1[@]};
}

function parseopt.begin() {
  parseopt.set $1 [INDEX]=1 [SUBINDEX]=0;
}

function parseopt.dump() { 

  local name;
  for name in $(parseopt.keys $1); do
    printf '%s: %s\n' $name "$(parseopt.get $1 $name)";
  done

}

function parseopt() {

  # PARAMETERS: $1 and $2 are names of associative arrays.
  # the output of the function will be placed in $2
  # the state of the parsing is saved in $1.

  # the remaining parameters are parsed. the number of items parsed are
  # returned in 2[SIZE].

  local PO_STATE=$1 RCRD_PARAMETER=$2; shift 2;

  local INDEX=$PO_STATE[INDEX] SUBINDEX=$PO_STATE[SUBINDEX];
  local PARAMETER=BASH_REMATCH[1] VALUE=BASH_REMATCH[2]
    
  parseopt.set $RCRD_PARAMETER [BRANCH]=0 [INDEX]=${!INDEX} [INPUT]="$1";
  # 1 test for long option
  [[ "$1" =~ ^--([a-zA-Z-]*[a-zA-Z])$ ]] && {
    parseopt.set $RCRD_PARAMETER [BRANCH]=1 \
      [PARAMETER]="${!PARAMETER}" [INDEX]=${!INDEX} \
        [SUBINDEX]=0 [VALUE]='' [SHORT]=0 [SIZE]=1;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE LONG) || return 11;
#    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SETTINGS) && {
#      parseopt.set $RCRD_PARAMETER [VALUE]="$2" [SIZE]=2;
#      let $INDEX++;
#    };
    let $INDEX++;
    return 0;
  }

  # 2 test for long option with setting specification
  [[ "$1" =~ ^--([a-zA-Z-]*[a-zA-Z]):$ ]] && {
    parseopt.set $RCRD_PARAMETER [BRANCH]=2 \
      [PARAMETER]="${!PARAMETER}" [INDEX]=${!INDEX} \
        [SUBINDEX]=0 [VALUE]="$2" [SHORT]=0 [SIZE]=2;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE LONG) || return 21;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SETTINGS) || return 22;
    let $INDEX+=2;
    return 0;
  }

  # 3 test for long option with setting specification and data
  [[ "$1" =~ ^--([a-zA-Z-]*[a-zA-Z])[:=](.*)$ ]] && {
    parseopt.set $RCRD_PARAMETER [BRANCH]=3 \
      [PARAMETER]="${!PARAMETER}" [INDEX]=${!INDEX} \
        [SUBINDEX]=0 [VALUE]="${!VALUE}" [SHORT]=0 [SIZE]=1;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE LONG) || return 31;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SETTINGS) || return 32;
    let $INDEX++;
    return 0;
  }

  # 4 test for short option
  [[ "$1" =~ ^-([a-zA-Z])$ ]] && {
    parseopt.set $RCRD_PARAMETER [BRANCH]=4 \
      [PARAMETER]="${!PARAMETER}" [INDEX]=${!INDEX} \
        [SUBINDEX]=0 [VALUE]="" [SHORT]=1 [SIZE]=1;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SHORT) || return 41;
#    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SETTINGS) && {
#      parseopt.set $RCRD_PARAMETER [VALUE]="$2" [SIZE]=2;
#      let $INDEX++;
#    };
    let $INDEX++;
    return 0;
  }

  # 5 test for short option with setting
  [[ "$1" =~ ^-([a-zA-Z]):$ ]] && {
    parseopt.set $RCRD_PARAMETER [BRANCH]=5 \
      [PARAMETER]="${!PARAMETER}" [INDEX]=${!INDEX} \
        [SUBINDEX]=0 [VALUE]="$2" [SHORT]=1 [SIZE]=2;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SHORT) || return 51;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SETTINGS) || return 52;
    let $INDEX+=2;
    return 0;
  }

  # 6 test for short option with setting and data
  [[ "$1" =~ ^-([a-zA-Z])[:=](.+)$ ]] && {
    parseopt.set $RCRD_PARAMETER [BRANCH]=6 \
      [PARAMETER]="${!PARAMETER}" [INDEX]=${!INDEX} \
        [SUBINDEX]=0 [VALUE]="${!VALUE}" [SHORT]=1 [SIZE]=1;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SHORT) || return 61;
    parseopt.match "${!PARAMETER}" $(parseopt.get $PO_STATE SETTINGS) || return 62;
    let $INDEX++;
    return 0;
  }
  
  # 7 test for multiple short option
  [[ "$1" =~ ^-([a-zA-Z]+)$ ]] && {
    local match=${BASH_REMATCH[1]};
    local -i length=${#match};
    local C=${match:${!SUBINDEX}:1};
    parseopt.set $RCRD_PARAMETER [BRANCH]=7 \
      [PARAMETER]="$C" [INDEX]=${!INDEX} \
        [SUBINDEX]=${!SUBINDEX} [VALUE]="" [SHORT]=1;
    parseopt.match "${C}" $(parseopt.get $PO_STATE SHORT) || return 71;
    let $SUBINDEX++;
    if (( $SUBINDEX == length )); then
      eval $RCRD_PARAMETER[SIZE]=1;
#      parseopt.match "${C}" $(parseopt.get $PO_STATE SETTINGS) && {
#        parseopt.set $RCRD_PARAMETER [VALUE]="$2" [SIZE]=2;
#        let $INDEX++;
#        true
#      } 
      let $INDEX++;
      let $SUBINDEX=0;
    else
      eval $RCRD_PARAMETER[SIZE]=0;
      parseopt.match "${C}" $(parseopt.get $PO_STATE SETTINGS) && {
        parseopt.match "$C" $(parseopt.get $PO_STATE HAS_DEFAULT) || return 72;
      } 
    fi;
    return 0;
  }

  # 8 test for multiple short option with setting
  [[ "$1" =~ ^-([a-zA-Z]+):$ ]] && {
    local match=${BASH_REMATCH[1]};
    local -i length=${#match};
    local C=${match:${!SUBINDEX}:1};
    parseopt.set $RCRD_PARAMETER [BRANCH]=8 \
      [PARAMETER]="$C" [INDEX]=${!INDEX} \
        [SUBINDEX]=${!SUBINDEX} [VALUE]="" [SHORT]=1;
    parseopt.match "${C}" $(parseopt.get $PO_STATE SHORT) || return 81;
    let $SUBINDEX++;
    if (( $SUBINDEX == length )); then
      eval $RCRD_PARAMETER[VALUE]="$2";
      eval $RCRD_PARAMETER[SIZE]=2;
      parseopt.match "${C}" $(parseopt.get $PO_STATE SETTINGS) && {
        parseopt.set $RCRD_PARAMETER [VALUE]="$2" [SIZE]=2;
        let $INDEX++;
      } 
      let $INDEX++;
      let $SUBINDEX=0;
    else
      eval $RCRD_PARAMETER[SIZE]=0;
      parseopt.match "${C}" $(parseopt.get $PO_STATE SETTINGS) && {
        parseopt.match "$C" $(parseopt.get $PO_STATE HAS_DEFAULT) || return 82;
      } 
    fi;
    return 0;
  }

  # 9 test for multiple short option with setting and data
  [[ "$1" =~ ^-([a-zA-Z]+)[:=](.+)$ ]] && {
    local match=${BASH_REMATCH[1]};
    local -i length=${#match};
    local C=${match:${!SUBINDEX}:1};
    parseopt.set $RCRD_PARAMETER [BRANCH]=1 \
      [PARAMETER]="$C" [INDEX]=${!INDEX} \
        [SUBINDEX]=${!SUBINDEX} [VALUE]="" [SHORT]=1;
    parseopt.match "${C}" $(parseopt.get $PO_STATE SHORT) || return 91;
    let $SUBINDEX++;
    if (( $SUBINDEX == length )); then
      eval $RCRD_PARAMETER[VALUE]="${BASH_REMATCH[2]}";
      eval $RCRD_PARAMETER[SIZE]=1;
      parseopt.match "${C}" $(parseopt.get $PO_STATE SETTINGS) && {
        parseopt.set $RCRD_PARAMETER [VALUE]="${!VALUE}";
      } 
      let $INDEX++;
      let $SUBINDEX=0;
    else
      eval $RCRD_PARAMETER[SIZE]=0;
      parseopt.match "${C}" $(parseopt.get $PO_STATE SETTINGS) && {
        parseopt.match "$C" $(parseopt.get $PO_STATE HAS_DEFAULT) || return 92;
      } 
    fi;
    return 0;
  }
  
  return 1;

}

OPTIONS="--get-theatre --help -L -Q: -d -e: -f -h -h: -i: -l -p -q: -r -s -s: -t -t: -z -z:";
FUNCTIONS="catalog directories files filter key-within-list links names parents parseopt read-pipe-parameters realpaths subset trace write-parameter-pipe";

(( DEBUG == 1 )) && {
  DEBUG_FUNCTIONS="declare dump.function.table filter.script subset.script";
}

declare -A CONFIG

parseopt.set CONFIG [LONG]="get-theatre help"
parseopt.set CONFIG [SHORT]="t L Q r d e f h i l l p q s z";
parseopt.set CONFIG [SETTINGS]="h Q t e i l q z s"
parseopt.set CONFIG [HAS_DEFAULT]="h t z s"

parseopt.begin CONFIG;

function dump.trace() {
{
      echo
      echo $command trace: 
      echo
      echo $'  0 '[:OUT-\>]
      echo  '  + '[compile]
      echo $'  1 'read OPTIONS left to right, for logical [dependency] order
      echo $'  + '[direction-flip: enter/exit/return]
      echo $' -1 'read right to left for output [composition] order.
      echo $'  = '[\(in function-level operations\)]
      echo $'  0 '[\<-IN: back through call chain]
      echo
      echo [OUT] $trace [IN]
      echo
    };
}

function call() {

  (( $# == 0 )) && {
    echo $COMMAND: error: invalid call: "no parameters were specified for the call with: ${trace/*<- /}";
    exit 1;
  } >&2;
  
  local name trace=${trace}
  [[ "$1" != trace ]] && trace+=" <- $1";
  [[ $DEBUG == 1 ]] && {  
    key-within-list $(echo $FUNCTIONS) "$1" && dump.trace
  }  >&2;

  key-within-list $OPTIONS $FUNCTIONS $DEBUG_FUNCTIONS "$1" && { 
    "$@"; exit $?; 
  };
  
  declare -A parse;
  parseopt.begin CONFIG;

  parseopt CONFIG parse "$@" || {
    echo "$COMMAND parameter parse error: code: $?: parameter #${parse[INDEX]} didn't parse" >&2;
    parseopt.dump parse;
    exit $code;
  }
  
  (( parse[BRANCH] > 5 )) && {
    local cmd="-${parse[PARAMETER]}";
    (( parse[SIZE] == 2 )) && cmd+=":";
    if [[ -n "${parse[VALUE]}" ]]; then
      $cmd: "${parse[VALUE]}" "${@:2}"; exit $?;    
    else
      $cmd -${parse[INPUT]:2} "${@:2}"; exit $?;
    fi;
  }
  
  parseopt.dump parse;

  {
    echo invalid command: "\`$1'";
    echo "type: $COMMAND --help or $COMMAND -h for $COMMAND help";
    exit 1;
  }  >&2;
  
}

function --help() {

cat <<EOF

$COMMAND [OPTIONS] FUNCTION [...]

General Purpose, Mutliple Record, File and String: Utility

 ALL REGULAR EXPRESSIONS, REGULARLY: EXTENDED.

License: MIT
GitHub: https://github.com/hypersoft/mapkit

(C) 2018; Triston-Jerard: Taylor;
          Hypersoft-Systems: U.-S.-A.

OPTION FLAGS

 --help  Show this help screen
  -h      Show this help screen.

 --get-theatre  Generates a hash-key-list of FUNCTIONS and OPTIONS.

 -r  Convert path record(s) to realpath(s).
 -d  Only print existing directories.
 -f  Only print existing files.
 -p  Only print parent directories.
 -l  Only print links.
 -L  Do not print links.
 -n  Only print file names.
 -z  Set Standards Compliant IFS = \$' \t\n'
 -t  Match the tail/type of records. Uses the RX char: \`\$'
 -h  Match the head/heading of records. Uses the RX char: \`^'

OPTION SETTINGS

 -t: TEXT     Sets the TAIL of all primary expressions to text.
 -h: TEXT     Sets the HEAD of all primary expressions to TEXT.

 -Q: TEXT     Sets the internal expression separator of the subset FUNCTION
              to TEXT. You may never need this option. The default is \$'\1'.
              This feature only affects the subset FUNCTION.

 -e: FILTER   Perform an exclude match against FILTER(s). Multiple filters may
              be supplied as a single parameter. The shell will expand the
              FILTERS according to IFS (see also OPTIONS: \`-z': and \`-z') for
              control of the shell expansion.

 -i: FILTER   Perform an include match against FILTER(s). Works like \`-e:'.
 
 -s: TYPE     Perform a sort by TYPE; where TYPE is:

               u for uniqe sort.
               v for version sort.
               n for name sort.
               
               [TYPES cannot be combined as a single parameter to \`-s:']

 -q: TEXT     Set regular-expression quoting character to TEXT for internal
              scripts. The default is \`'".

 -z: TEXT     Sets the IFS variable to TEXT. See your shell manual about IFS.

FUNCTIONS

 NOTE: most FUNCTIONS have shortcuts in the OPTIONS section for advanced use.

 catalog [-m NUMBER] -- DIRECTORY [...]
 
   Lists the files in DIRECTOR(IES). If option -m is supplied, it limits the
   maximum depth of the search; where 1 means do not traverse any children of
   the DIRECTORY; 2 is children of child DIRECTORY, so on and so forth.

 directories FILE ...     Lists only the directories in FILE(S).
 files FILE ...           Lists only the file(s) in FILE(S).

 filter [-e] -- MATCH-PATTERN ...
                
  Searches through stdin line records seeking MATCH-PATTERN(S). If MATCH-PATTERN
  is found it is written to stdout unless the -e option has been specified. If
  the -e option has been specified, all matches are excluded from output.

 names FILE ...           Lists only the name parts of FILE(S).
 parents FILE ...         Lists only the parent-directories of FILE(S).

 links [-e] -- FILE ...   Lists only the links in FILE(S). With \`-e', lists
                          all files which are NOT links.

 read-pipe-parameters COMMAND or FUNCTION [OPTIONS]
 
   Read lines from input and send them as parameters to COMMAND or FUNCTION
   with any OPTIONS.
   
   [FORMERLY: pipe]

 write-parameter-pipe  ...  Converts all parameters to line-stream-output.
 
 trace SOMETHING     Performs a debug trace explaining dependency chain,
                     backwards AND forwards [quantum-filters ;)].
                     
 realpaths FILE ...       List only the realpath(s) of FILE(S).

 key-within-list VALUES... KEY  
 
   Searches through values for key. Returns success if literally found. Ready
   made for read-pipe-parameters FUNCTION.

 subset CUT-PATTERN PASTE-TEXT[ CUT-PATTERN PASTE-TEXT[ ...]]
 
   Searches through stdin line records using CUT-PATTERN and replaces matches
   with PASTE-TEXT. Multiple CUT-PATTERN and PASTE-TEXT expressions may be
   supplied. Use the write-parameter-pipe FUNCTION if stdio is not convenient.

NOTE:

 (1) OPTIONS affect the output of FUNCTIONS.

 (2) OPTIONS are executed in REVERSE-ORDER of command specification; except:
     (1) when an OPTION is not a shortcut to a FUNCTION.
         (1.a) if the OPTION is not a shortcut to a FUNCTION, it is instantly
               applied THROUGH the OPTION or FUNCTION following it in the
               command specification. Which means all environment OPTIONS are
               immediately effective at the beginning of the command following
               it; being of the form: [ENVIRONMENT] OPTION OR FUNCTION.

               [see: the function definitions of the OPTIONS in source code
                     to verify the above form.
                
                  file://$(realpath $0)
               ]

See: "regex - POSIX.2 regular expressions" within the Linux Programmer's Manual
     for help on expressions with and without the -E OPTION.

END $COMMAND --help ############################################################

$COMMAND [OPTIONS] FUNCTION [...]

General Purpose, Mutliple Record, File and String: Utility

License: MIT
GitHub: https://github.com/hypersoft/mapkit

                                           (C) 2018; Triston-Jerard: Taylor;
                                                     Hypersoft-Systems: U.-S.-A.

EOF

exit 1;

} >&2;


trace='' call "$@";

TODO:

  Lesser used functions, having no short-cuts.
    
  help section about regular: regular expressions -- lol and extended regular
  expressions.

